/**
 * SMOZ CLI: register
 *
 * Scan app/functions/** for {lambda,openapi,serverless}.ts and generate
 * side-effect import modules under app/generated/:
 *  - register.functions.ts
 *  - register.openapi.ts
 *  - register.serverless.ts
 *
 * Idempotent and formatted (uses Prettier if available).
 */
import { existsSync } from 'node:fs';
import { promises as fs } from 'node:fs';
import { dirname, join, posix, relative, sep } from 'node:path';

type Buckets = {
  lambda: string[];
  openapi: string[];
  serverless: string[];
};

const toPosix = (p: string): string => p.split(sep).join('/');
const withoutTsExt = (p: string): string =>
  p.endsWith('.ts') ? p.slice(0, -3) : p;

const HEADER = `/* AUTO-GENERATED by smoz register — DO NOT EDIT */
`;

const formatMaybe = async (root: string, filePath: string, source: string) => {
  try {
    // Resolve Prettier if available in the project

    const prettier = (await import('prettier')) as unknown as {
      resolveConfig: (p: string) => Promise<Record<string, unknown> | null>;
      format: (s: string, o: Record<string, unknown>) => string;
    };
    const cfg = (await prettier.resolveConfig(root)) ?? {};
    return prettier.format(source, { ...cfg, filepath: filePath });
  } catch {
    return source;
  }
};

const writeIfChanged = async (
  outFile: string,
  content: string,
): Promise<boolean> => {
  try {
    const prev = await fs.readFile(outFile, 'utf8');
    if (prev === content) return false;
  } catch {
    // file missing — proceed
  }
  await fs.mkdir(dirname(outFile), { recursive: true });
  await fs.writeFile(outFile, content, 'utf8');
  return true;
};

const walk = async (dir: string, out: string[] = []): Promise<string[]> => {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const ent of entries) {
    const p = join(dir, ent.name);
    if (ent.isDirectory()) {
      await walk(p, out);
    } else if (ent.isFile()) {
      out.push(p);
    }
  }
  return out;
};

const collect = async (root: string): Promise<Buckets> => {
  const base = join(root, 'app', 'functions');
  const buckets: Buckets = { lambda: [], openapi: [], serverless: [] };
  if (!existsSync(base)) return buckets;

  const files = await walk(base);
  for (const abs of files) {
    const name = abs.split(sep).pop() ?? '';
    if (name === 'lambda.ts') buckets.lambda.push(abs);
    if (name === 'openapi.ts') buckets.openapi.push(abs);
    if (name === 'serverless.ts') buckets.serverless.push(abs);
  }
  // stable order
  buckets.lambda.sort();
  buckets.openapi.sort();
  buckets.serverless.sort();
  return buckets;
};

/**
 * Build ESM import lines using POSIX-relative specifiers from the generated
 * file directory (app/generated) to each target file. Avoids "@/" alias so
 * dynamic import in the inline server works reliably under tsx.
 */
const makeImports = (root: string, outDir: string, files: string[]): string[] =>
  files.map((abs) => {
    const relFromOut = toPosix(relative(outDir, abs));
    const noExt = withoutTsExt(relFromOut);
    const spec = noExt.startsWith('.') ? noExt : `./${noExt}`;
    return `import '${spec}';`;
  });

const buildFile = (imports: string[]): string => {
  if (imports.length === 0) return `${HEADER}\n`;
  return `${HEADER}\n${imports.join('\n')}\n`;
};
export const runRegister = async (
  root: string,
): Promise<{
  wrote: string[];
}> => {
  const buckets = await collect(root);

  const outDir = join(root, 'app', 'generated');
  const lambdaImports = makeImports(root, outDir, buckets.lambda);
  const openapiImports = makeImports(root, outDir, buckets.openapi);
  const serverlessImports = makeImports(root, outDir, buckets.serverless);

  const fnsPath = join(outDir, 'register.functions.ts');
  const oaiPath = join(outDir, 'register.openapi.ts');
  const srvPath = join(outDir, 'register.serverless.ts');

  const fns = await formatMaybe(root, fnsPath, buildFile(lambdaImports));
  const oai = await formatMaybe(root, oaiPath, buildFile(openapiImports));
  const srv = await formatMaybe(root, srvPath, buildFile(serverlessImports));

  const wrote: string[] = [];
  if (await writeIfChanged(fnsPath, fns)) wrote.push(posix.normalize(fnsPath));
  if (await writeIfChanged(oaiPath, oai)) wrote.push(posix.normalize(oaiPath));
  if (await writeIfChanged(srvPath, srv)) wrote.push(posix.normalize(srvPath));

  return { wrote };
};
