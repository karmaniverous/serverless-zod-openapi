# Global Requirements & Cross‑Cutting Concerns

Durable, repo‑specific requirements for @karmaniverous/smoz. Keep business‑logic
comments lean; record intent and stable policies here.

Contents

1. Repository scope and publishing
2. Architecture and application model
3. HTTP middleware policy (order and behavior)
4. Aggregation builders (Serverless + OpenAPI)
5. CLI — commands, dev loop, and local modes
6. Register freshness (Serverless plugin) and optional hooks
7. Templates — baseline, TypeScript configs, ESLint, and placeholders
8. Init UX — conflicts, installation, defaults, and manifest handling
9. Routing, path normalization, and portability
10. Event tokens and HTTP tokens
11. App‑level function defaults (env keys)
12. Types hygiene (reuse public platform types)
13. Lint/format and template scalability
14. Documentation structure and Typedoc ordering
15. Integration fixture (/app)
16. Install guard (operators may forget install)

---

## 1) Repository scope and publishing

- Publish only the toolkit and templates to npm:
  - files: ["dist", "templates"]
  - The /app fixture is not published; it is for CI validation only.
- The toolkit surface includes:
  - Runtime wrapper and HTTP middleware building blocks.
  - Serverless/OpenAPI aggregators and helpers.
  - Configuration typing and utilities (e.g., path helpers).

## 2) Architecture and application model

Schema‑first App with a registry:

- App.create(config) captures:
  - Global/stage parameter schemas and env exposure nodes.
  - Event type map schema and runtime HTTP tokens.
  - Implementation‑wide Serverless defaults.
  - Stage artifacts: provider environment, params, and a per‑function env builder.
- Define functions in small modules (lambda.ts), register OpenAPI (openapi.ts),
  and add non‑HTTP extras (serverless.ts) when applicable.
- Registry provides per‑function APIs:
  - handler(business), openapi(baseOperation), serverless(extras).
- Loaders (side‑effect registers generated by CLI):
  - app/generated/register.functions.ts — imports all lambda.ts
  - app/generated/register.openapi.ts — imports all openapi.ts
  - app/generated/register.serverless.ts — imports non‑HTTP serverless.ts

## 3) HTTP middleware policy (order and behavior)

Canonical order (must remain stable):

1. HEAD short‑circuit (returns 200 {} immediately)
2. Header normalizer
3. APIGateway v1 event normalizer
4. Content negotiation (JSON + vendor +json)
5. JSON body parser (no 415 on missing content type)
6. Zod validation (before handler; after handler)
7. Error exposure (maps validation failures to 400)
8. http‑error‑handler (uses ConsoleLogger)
9. CORS (credentials on; preserves computed origin)
10. Preferred media defaults across phases
11. Response shaper (enforce Content‑Type; ensure string body)
12. Response serializer (JSON + vendor +json)

Acceptance:

- HEAD is finalized to 200 {} and is not post‑validated.
- Shaped/string bodies pass transparently; others are shaped.
- Zod validation failures map to 400; other errors are exposed per handler.

## 4) Aggregation builders

- buildAllServerlessFunctions():
  - For HTTP tokens: derive method/basePath/contexts (or infer from paths)
    and produce handler strings. Provider env comes from app; per‑function env
    is built from explicit fnEnvKeys excluding globally exposed keys.
  - For non‑HTTP tokens: pass through extras supplied via serverless(extras).
- buildAllOpenApiPaths():
  - Merge path items for each configured context. OperationIds are composed
    as `${segments}_${method}` with a context prefix for non‑public routes.

## 5) CLI — commands, dev loop, and local modes

Conventions:

- Author code lives under app/config/app.config.ts and app/functions/<eventType>/...
- Generated artifacts live under app/generated/ (register.\*.ts and openapi.json).

Commands:

- smoz init — scaffold app files, seed empty registers, add serverless.ts and
  an OpenAPI build script; optionally install dependencies.
- smoz register — one‑shot; generate app/generated/register.functions.ts,
  register.openapi.ts, and register.serverless.ts; idempotent and formatted.
- smoz openapi — one‑shot; run the app’s OpenAPI builder script.
- smoz dev — orchestrated watch loop:
  1. register (if enabled),
  2. openapi (if enabled),
  3. local serving (restart/refresh if applicable).

Dev loop flags (precedence: CLI > cliDefaults.dev > hard defaults):

- -r/--register | -R/--no-register (default: on)
- -o/--openapi | -O/--no-openapi (default: on)
- -l/--local [inline|offline|false] (default: inline once available)
- -s/--stage <name> (default: first non-"default" stage; fallback "dev")
- -p/--port <n> (default: 0 → random free port)
- -v/--verbose

Source watch set:

- app/functions/\*\*/{lambda.ts,openapi.ts,serverless.ts}
- Single debounced queue (~250 ms). Never run steps concurrently. Print "Updated" vs "No changes".

Local modes (HTTP):

- offline (serverless‑offline): spawn serverless offline start; pre‑run
  register+openapi; restart child on route surface change; prefix child output.
- inline (default once implemented): in‑process server mapping Node HTTP →
  APIGatewayProxyEvent (v1) → wrapped handler. Build route table from
  app.buildAllServerlessFunctions(); HEAD, content negotiation, and error
  mapping are handled by the wrapper. Print route table and resolved port.

Stage & environment in dev:

- Stage default: first stage key in app.stages not named "default"; fallback dev.
- Seed process.env from app.global.params and app.stage.params[stage] so dev
  mirrors provider env semantics.

## 6) Register freshness (Serverless plugin) and optional hooks

- Provide a lightweight Serverless v4 plugin (exported as
  @karmaniverous/smoz/serverless-plugin) that runs smoz register before
  package/deploy steps. Keep it small and fail fast.
- Optional pre‑commit recipe (documented, not enforced): run smoz register when
  app/functions/\*_ changes and stage updated register._.ts files.

Continue chaining register into scripts that depend on fresh registers:

- openapi: register && tsx app/config/openapi && prettier
- package/deploy: register && serverless ...

## 7) Templates — baseline, TypeScript configs, ESLint, and placeholders

Baseline:

- Single "default" template (REST‑only baseline) including:
  - app/config/app.config.ts
  - app/functions/rest/hello/get/{lambda,handler,openapi}.ts
  - app/functions/rest/openapi/get/{lambda,handler,openapi}.ts
  - serverless.ts
  - app/config/openapi.ts and scripts (register/openapi/package/dev)
- Non‑HTTP examples are added via smoz add or referenced under /examples.

TypeScript configs (two‑tsconfig approach):

- Dev tsconfig (templates/default/tsconfig.json) — for in‑repo development:
  - Maps @karmaniverous/smoz → ../../dist so editors and typed ESLint resolve
    the toolkit without publishing.
- Downstream tsconfig (templates/default/tsconfig.downstream.json) — ships to apps:
  - smoz init renames this to tsconfig.json (writes tsconfig.json.example if a
    tsconfig already exists).
  - Contains no repo‑local path mappings.
- Typed ESLint project (templates/default/tsconfig.eslint.json) — extend‑only:
  - extends: ./tsconfig.json so typed ESLint resolves types consistently in both
    contexts (in‑repo and downstream).
  - Provides a place for lint‑only tweaks without perturbing the compiler.

Template ESLint:

- A unified ESLint flat config (templates/default/eslint.config.ts) drives typed
  lint for template sources using tseslint with project ['./tsconfig.eslint.json']
  and tsconfigRootDir set to the template directory.

Template typecheck:

- A small script discovers templates/\*/tsconfig.json and runs
  tsc -p --noEmit per template (no per‑template wiring).

Register placeholders policy:

- Templates must typecheck in a clean clone without running CLI steps. Ship a
  single ambient declarations file that declares:
  - '@/app/generated/register.functions'
  - '@/app/generated/register.openapi'
  - '@/app/generated/register.serverless'
- Runtime placeholders are created in real apps by smoz init and maintained by
  smoz register; templates should not include app/generated placeholders.

## 8) Init UX — conflicts, installation, defaults, and manifest handling

- Template selection: -t/--template accepts a packaged template name ("default")
  or a filesystem directory path.
- Conflict handling (non‑package.json files):
  - Interactive: Overwrite, Add example (<file>.example), Skip. Provide "apply to all".
  - Non‑interactive (-y): governed by cliDefaults.init.onConflict (ask|overwrite|example|skip);
    default is "example"; --conflict overrides.
- Installation:
  - With -y: perform install by default using the detected PM (npm|pnpm|yarn|bun).
    Overrides: --no-install or --install <pm>.
  - Without -y: prompt for install; in CI, use -y with an explicit --install.
- Aliases and version flag: add -t/--template, -y/--yes, and -v/--version where appropriate.
- Defaults file (optional): smoz.config.json may provide
  cliDefaults.init.onConflict, cliDefaults.init.install, cliDefaults.init.template,
  and cliDefaults.dev.local.

Manifest handling:

- Do not copy the template’s package.json during init.
- Always handle the manifest via an additive merge:
  - Create when missing; otherwise merge dependencies/devDependencies/peerDependencies
    and scripts only when absent; never overwrite existing keys.
- This avoids unnecessary conflict prompts for package.json while keeping behavior predictable.

## 9) Routing, path normalization, and portability

- One function per method/basePath; HEAD is auto‑handled by the middleware
  (do not author duplicate HEAD routes).
- Multiple security contexts via httpContexts (public/private/my); non‑public
  paths receive a context prefix in Serverless and OpenAPI surfaces.
- Normalize all paths to POSIX separators in authored code and generated artifacts.
- Provide small helpers (toPosixPath, dirFromHere) for cross‑platform hygiene.

## 10) Event tokens and HTTP tokens

- The single source of truth for event tokens is baseEventTypeMapSchema
  (rest, http, sqs, ...). Extend it per project needs.
- defaultHttpEventTypeTokens establishes which tokens are treated as HTTP at runtime.

## 11) App‑level function defaults (env keys)

- App.create accepts optional functionDefaults.fnEnvKeys.
- Registry merges defaults and per‑function fnEnvKeys.
- Provider‑level environment is built from globally exposed keys; per‑function
  env includes only additional keys (excluding globals).

## 12) Types hygiene (reuse public platform types)

- Never redeclare platform types that exist in public dependencies; import from
  aws-lambda or toolkit contracts.
- Inline dev server (HTTP):
  - Use APIGatewayProxyEvent (v1) and APIGatewayProxyResult (and Context) from aws‑lambda.
  - Mapping: Node HTTP → APIGatewayProxyEvent (v1) → wrapped handler; pass the
    resulting envelope through.

## 13) Lint/format and template scalability

- Prettier is the single source of truth for formatting; ESLint defers to Prettier and enforces TypeScript/ordering rules.
- Keep imports sorted (simple‑import‑sort).
- A unified templates ESLint config enables typed lint for all templates without per‑template edits.
- Template typecheck script scales to new templates by discovering tsconfig.json.

## 14) Documentation structure and Typedoc ordering

- External docs (docs-src/\*.md) include front matter (title, sidebar_label, sidebar_position).
- Typedoc ordering in typedoc.json "projectDocuments":
  1. Overview
  2. Why smoz?
  3. Getting started
  4. 10‑minute tour
  5. Middleware
  6. Recipes (index + subpages)
  7. Templates
  8. CLI
  9. Contributing
  10. CHANGELOG.md
- Exclude CLI source symbols (src/cli/\*\*) from API reference to avoid confusion; CLI usage is documented in docs-src/cli.md.

## 15) Integration fixture (/app)

Purpose:

- Keep a small in‑tree example app to validate end‑to‑end flows in CI
  (register → OpenAPI → package). Not intended for deployment and not published.

Policy:

- Keep /app on main to avoid bitrot; do not move it to a long‑lived branch.
- Neutral identifiers:
  - service: smoz-sample
  - domains: api.example.test / api.dev.example.test
  - ARNs: placeholders
- Provide /app/README.md explaining purpose and non‑publish status.
- Ensure repository scripts operate against the fixture without deploy (package only).

## 16) Install guard (operators may forget install)

- Detect and surface likely missing installs (no node_modules/ or common module‑not‑found logs for core dependencies).
- Prompt users to run their package manager’s install rather than adding shims.
- Remove accidental shims after install.

## 17) Logger shape

- Any accepted logger must satisfy ConsoleLogger (console‑compatible).
- Defaults use console; middleware and wrappers rely on ConsoleLogger.

## 18) OpenAPI specs (hand‑crafted)

- OpenAPI specs are authored by hand; no automatic derivation from Zod.
- When useful, use z.any() as placeholders and refine iteratively.

## 19) Testability of environment config

- Avoid top‑level ESM imports from config paths that complicate vi.mock();
  prefer lazy imports inside functions to keep tests predictable.
- Avoid dynamic type imports.
